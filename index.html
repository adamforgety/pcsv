<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- CRITICAL for iPad/Tablet Compatibility -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>PianoViz</title>
    <meta name="theme-color" content="#3b82f6" />
    <!-- PWA Manifest Link - USING RELATIVE PATH -->
    <link rel="manifest" href="./manifest.json">
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        .key-shadow {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body class="p-1 h-screen flex items-center justify-center">
    <div class="w-full max-w-4xl bg-white rounded-xl shadow-2xl p-4 md:p-6 h-[98%] overflow-y-auto">
        <header class="mb-6">
            <h1 class="text-3xl md:text-4xl font-extrabold text-gray-900 mb-1 rotate-1 text-center">
                PianoViz
            </h1>
            <p class="text-center text-gray-600 text-sm md:text-base">
                Visualize harmony on your phone or tablet.
            </p>
        </header>
        <!-- Mode Selection Buttons -->
        <div class="flex justify-center space-x-4 mb-6">
            <button id="chordModeBtn" class="px-6 py-2 rounded-full font-bold text-lg transition-all duration-200 shadow-md transform hover:scale-[1.02] bg-blue-600 text-white hover:bg-blue-700 active:bg-blue-800 focus:outline-none focus:ring-4 focus:ring-blue-300">Chord Mode</button>
            <button id="scaleModeBtn" class="px-6 py-2 rounded-full font-bold text-lg transition-all duration-200 shadow-md transform hover:scale-[1.02] bg-gray-200 text-gray-700 hover:bg-gray-300 active:bg-gray-400 focus:outline-none focus:ring-4 focus:ring-gray-300">Scale Mode</button>
        </div>
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 mb-6">
            <div class="space-y-1">
                <label for="rootNote" class="block text-sm font-medium text-gray-700">Root Note</label>
                <select id="rootNote" class="block w-full pl-3 pr-10 py-2.5 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-lg rounded-lg border key-shadow bg-gray-50"></select>
            </div>
            <div class="space-y-1">
                <label for="type" class="block text-sm font-medium text-gray-700">Type</label>
                <select id="type" class="block w-full pl-3 pr-10 py-2.5 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-lg rounded-lg border key-shadow bg-gray-50"></select>
            </div>
            <div class="space-y-1">
                <label for="inversion" class="block text-sm font-medium text-gray-700">Inversion</label>
                <select id="inversion" class="block w-full pl-3 pr-10 py-2.5 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-lg rounded-lg border key-shadow bg-gray-50" disabled></select>
            </div>
        </div>
        <div class="flex flex-col items-center">
            <h2 id="resultName" class="text-xl font-semibold text-gray-800 mb-3 text-center h-6"></h2>
            <div class="sm:hidden w-full text-center text-sm p-2 bg-indigo-100 text-indigo-800 rounded-lg mb-4 key-shadow">
                ðŸ’¡ <b>Tip:</b> Rotate your device to landscape mode for a wider, clearer view!
            </div>
            <div id="keyboardContainer" class="relative w-full p-4 bg-gray-100 rounded-lg key-shadow">
                <svg id="pianoSvg" height="220" preserveAspectRatio="xMidYMid slice"></svg>
            </div>
        </div>
    </div>
    <script>
        // --- Core Configuration Data ---
        let currentMode = 'chord';
        const NOTE_INFO = [
            { id: 0, name: "C", alt: "C" },
            { id: 1, name: "C#", alt: "Db" },
            { id: 2, name: "D", alt: "D" },
            { id: 3, name: "D#", alt: "Eb" },
            { id: 4, name: "E", alt: "E" },
            { id: 5, name: "F", alt: "F" },
            { id: 6, name: "F#", alt: "Gb" },
            { id: 7, name: "G", alt: "G" },
            { id: 8, name: "G#", alt: "Ab" },
            { id: 9, name: "A", alt: "A" },
            { id: 10, name: "A#", alt: "Bb" },
            { id: 11, name: "B", alt: "B" }
        ];
        const DEFINITIONS = {
            'major': { intervals: [0, 4, 7], name: 'Major', min_notes: 3, isScale: false },
            'minor': { intervals: [0, 3, 7], name: 'Minor', min_notes: 3, isScale: false },
            'dom7': { intervals: [0, 4, 7, 10], name: 'Dominant 7th', min_notes: 4, isScale: false },
            'min7': { intervals: [0, 3, 7, 10], name: 'Minor 7th', min_notes: 4, isScale: false },
            'major_scale': { intervals: [0, 2, 4, 5, 7, 9, 11], name: 'Major Scale', min_notes: 7, isScale: true },
            'minor_scale': { intervals: [0, 2, 3, 5, 7, 8, 10], name: 'Natural Minor Scale', min_notes: 7, isScale: true },
            'pentatonic_major': { intervals: [0, 2, 4, 7, 9], name: 'Pentatonic Major', min_notes: 5, isScale: true },
            'pentatonic_minor': { intervals: [0, 3, 5, 7, 10], name: 'Pentatonic Minor', min_notes: 5, isScale: true }
        };
        const INVERSIONS = [
            { value: 0, name: "Root Position" },
            { value: 1, name: "1st Inversion" },
            { value: 2, name: "2nd Inversion" },
            { value: 3, name: "3rd Inversion" }
        ];
        const KEYBOARD_CONFIG = {
            TOTAL_KEYS: 49,
            WHITE_KEYS_COUNT: 29,
            KEYBOARD_WIDTH: 1900,
            KEYBOARD_HEIGHT: 220,
            KEY_Y_START: 10,
            WHITE_KEY_HEIGHT: 200,
            WHITE_KEY_WIDTH: 1900 / 29,
            BLACK_KEY_WIDTH: (1900 / 29) * 0.6,
            BLACK_KEY_HEIGHT: 120
        };
        function getNoteFullName(globalIndex, spellingPreference) {
            const octave = 3 + Math.floor(globalIndex / 12);
            const semitoneIndex = globalIndex % 12;
            const info = NOTE_INFO[semitoneIndex];
            let baseName;
            if (info.name === info.alt) {
                baseName = info.alt;
            } else if (spellingPreference === 'flat') {
                baseName = info.alt;
            } else {
                baseName = info.name;
            }
            return baseName + octave;
        }
        function getKeyXPosition(absoluteIndex) {
            if (absoluteIndex < 0 || absoluteIndex >= KEYBOARD_CONFIG.TOTAL_KEYS) return -999;
            const noteMod12 = absoluteIndex % 12;
            const isWhiteKey = [0, 2, 4, 5, 7, 9, 11].includes(noteMod12);
            const WKW = KEYBOARD_CONFIG.WHITE_KEY_WIDTH;
            const BKW = KEYBOARD_CONFIG.BLACK_KEY_WIDTH;
            let whiteKeyCount = 0;
            for (let i = 0; i < absoluteIndex; i++) {
                if ([0, 2, 4, 5, 7, 9, 11].includes(i % 12)) whiteKeyCount++;
            }
            if (isWhiteKey) {
                return whiteKeyCount * WKW;
            } else {
                return (whiteKeyCount * WKW) - (BKW / 2);
            }
        }
        function calculateNotes(rootInfo, typeKey, inversionIndex) {
            const { rootIndex, rootPreference } = rootInfo;
            const definition = DEFINITIONS[typeKey];
            if (!definition) return { highlighted: [], name: "Select a Type", rootPreference: rootPreference };
            const highlightedNotes = [];
            let intervals = [...definition.intervals];
            let rootNameDisplay = NOTE_INFO[rootIndex].name;
            if (rootPreference === 'flat' && NOTE_INFO[rootIndex].alt !== NOTE_INFO[rootIndex].name) {
                rootNameDisplay = NOTE_INFO[rootIndex].alt;
            }
            let name = rootNameDisplay + " " + definition.name;
            const isChord = !definition.isScale;
            const maxInversion = definition.min_notes - 1;
            if (!isChord && intervals.length === 7) intervals.push(12);
            if (isChord && inversionIndex > 0 && inversionIndex <= maxInversion) {
                for (let i = 0; i < inversionIndex; i++) {
                    intervals.push(intervals.shift() + 12);
                }
                name += ` (${INVERSIONS[inversionIndex].name})`;
            }
            let octaveOffset = 0;
            const highestInterval = intervals[intervals.length - 1] || 0;
            const highestNeededSemitone = rootIndex + highestInterval;
            const maxKeyIndex = KEYBOARD_CONFIG.TOTAL_KEYS - 1;
            if (isChord) {
                const idealOffset = 12;
                if (highestNeededSemitone + idealOffset <= maxKeyIndex) {
                    octaveOffset = idealOffset;
                }
                else if (highestNeededSemitone + 0 <= maxKeyIndex) {
                    octaveOffset = 0;
                }
                else if (rootIndex - 12 >= 0) {
                    octaveOffset = -12;
                }
            } else {
                const idealOffset = 12;
                const candidateHighestSemitone = rootIndex + highestInterval + idealOffset;
                if (candidateHighestSemitone <= maxKeyIndex) {
                    octaveOffset = idealOffset;
                } else {
                    octaveOffset = 0;
                }
            }
            intervals.forEach(interval => {
                let finalIndex = rootIndex + interval + octaveOffset;
                if (finalIndex >= 0 && finalIndex <= maxKeyIndex) {
                    highlightedNotes.push(finalIndex);
                }
            });
            const uniqueNotes = Array.from(new Set(highlightedNotes)).sort((a, b) => a - b);
            return {
                highlighted: uniqueNotes,
                name: name,
                isScale: definition.isScale || false,
                rootPreference: rootPreference
            };
        }
        function drawKeyboard(highlightedIndices = [], rootPreference = 'sharp') {
            const svg = document.getElementById('pianoSvg');
            svg.innerHTML = '';
            const WKW = KEYBOARD_CONFIG.WHITE_KEY_WIDTH;
            const BKW = KEYBOARD_CONFIG.BLACK_KEY_WIDTH;
            const WKH = KEYBOARD_CONFIG.WHITE_KEY_HEIGHT;
            const Y_START = KEYBOARD_CONFIG.KEY_Y_START;
            let whiteKeyIndex = 0;
            const WHITE_KEY_COLOR = '#ffffff';
            const BLACK_KEY_COLOR = '#1f2937';
            const HIGHLIGHT_WHITE_COLOR = '#3b82f6';
            const HIGHLIGHT_BLACK_COLOR = '#1d4ed8';
            for (let i = 0; i < KEYBOARD_CONFIG.TOTAL_KEYS; i++) {
                const semitoneIndex = i % 12;
                const octave = 3 + Math.floor(i / 12);
                let noteNameDisplay = NOTE_INFO[semitoneIndex].name;
                if (rootPreference === 'flat' && NOTE_INFO[semitoneIndex].alt !== NOTE_INFO[semitoneIndex].name) {
                    noteNameDisplay = NOTE_INFO[semitoneIndex].alt;
                }
                const fullNoteName = noteNameDisplay + octave;
                if ([0, 2, 4, 5, 7, 9, 11].includes(semitoneIndex)) {
                    const isHighlighted = highlightedIndices.includes(i);
                    const x = whiteKeyIndex * WKW;
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute('x', x);
                    rect.setAttribute('y', Y_START);
                    rect.setAttribute('width', WKW);
                    rect.setAttribute('height', WKH);
                    rect.setAttribute('rx', 4);
                    rect.setAttribute('ry', 4);
                    rect.setAttribute('stroke', '#a1a1aa');
                    rect.setAttribute('stroke-width', '1');
                    rect.setAttribute('fill', isHighlighted ? HIGHLIGHT_WHITE_COLOR : WHITE_KEY_COLOR);
                    rect.classList.add('white-key');
                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute('x', x + WKW / 2);
                    text.setAttribute('y', Y_START + WKH - 10);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', '14');
                    text.setAttribute('fill', isHighlighted ? '#ffffff' : '#4b5563');
                    text.textContent = fullNoteName;
                    svg.appendChild(rect);
                    svg.appendChild(text);
                    whiteKeyIndex++;
                }
            }
            for (let i = 0; i < KEYBOARD_CONFIG.TOTAL_KEYS; i++) {
                const semitoneIndex = i % 12;
                if ([1, 3, 6, 8, 10].includes(semitoneIndex)) {
                    const isHighlighted = highlightedIndices.includes(i);
                    let whiteKeyToTheLeftIndex = 0;
                    for (let j = 0; j < i; j++) {
                        if ([0, 2, 4, 5, 7, 9, 11].includes(j % 12)) {
                            whiteKeyToTheLeftIndex++;
                        }
                    }
                    const x = (whiteKeyToTheLeftIndex * WKW) - (BKW / 2);
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute('x', x);
                    rect.setAttribute('y', Y_START);
                    rect.setAttribute('width', BKW);
                    rect.setAttribute('height', KEYBOARD_CONFIG.BLACK_KEY_HEIGHT);
                    rect.setAttribute('rx', 3);
                    rect.setAttribute('ry', 3);
                    rect.setAttribute('stroke', '#000000');
                    rect.setAttribute('stroke-width', '1');
                    rect.setAttribute('fill', isHighlighted ? HIGHLIGHT_BLACK_COLOR : BLACK_KEY_COLOR);
                    rect.classList.add('black-key');
                    svg.appendChild(rect);
                    if (isHighlighted) {
                        const noteInfo = NOTE_INFO[semitoneIndex];
                        let noteBaseName;
                        if (rootPreference === 'flat' && noteInfo.alt !== noteInfo.name) {
                            noteBaseName = noteInfo.alt;
                        } else {
                            noteBaseName = noteInfo.name;
                        }
                        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        text.setAttribute('x', x + BKW / 2);
                        text.setAttribute('y', Y_START + KEYBOARD_CONFIG.BLACK_KEY_HEIGHT - 10);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('font-size', '14');
                        text.setAttribute('fill', '#ffffff');
                        text.textContent = noteBaseName;
                        svg.appendChild(text);
                    }
                }
            }
        }
        const rootNoteSelect = document.getElementById('rootNote');
        const typeSelect = document.getElementById('type');
        const inversionSelect = document.getElementById('inversion');
        const resultName = document.getElementById('resultName');
        const keyboardContainer = document.getElementById('keyboardContainer');
        const svg = document.getElementById('pianoSvg');
        function getFilteredDefinitions(mode) {
            return Object.fromEntries(
                Object.entries(DEFINITIONS).filter(([key, def]) => {
                    return mode === 'chord' ? !def.isScale : def.isScale;
                })
            );
        }
        function updateModeButtons() {
            const chordModeBtn = document.getElementById('chordModeBtn');
            const scaleModeBtn = document.getElementById('scaleModeBtn');
            const activeClasses = 'bg-blue-600 text-white hover:bg-blue-700 active:bg-blue-800 focus:ring-blue-300';
            const inactiveClasses = 'bg-gray-200 text-gray-700 hover:bg-gray-300 active:bg-gray-400 focus:ring-gray-300';
            const baseClasses = 'px-6 py-2 rounded-full font-bold text-lg transition-all duration-200 shadow-md transform hover:scale-[1.02] focus:outline-none focus:ring-4';
            if (currentMode === 'chord') {
                chordModeBtn.className = `${baseClasses} ${activeClasses}`;
                scaleModeBtn.className = `${baseClasses} ${inactiveClasses}`;
            } else {
                chordModeBtn.className = `${baseClasses} ${inactiveClasses}`;
                scaleModeBtn.className = `${baseClasses} ${activeClasses}`;
            }
        }
        function handleModeChange(newMode) {
            if (currentMode === newMode) return;
            currentMode = newMode;
            updateModeButtons();
            populateSelectors();
            updateVisualization();
        }
        function populateSelectors() {
            if (rootNoteSelect.options.length === 0) {
                NOTE_INFO.forEach(info => {
                    if (info.name === info.alt) {
                        const option = document.createElement('option');
                        option.value = `${info.id}_sharp`;
                        option.textContent = info.name;
                        if (info.id === 0) {
                            option.selected = true;
                        }
                        rootNoteSelect.appendChild(option);
                    } else {
                        const optionSharp = document.createElement('option');
                        optionSharp.value = `${info.id}_sharp`;
                        optionSharp.textContent = info.name;
                        rootNoteSelect.appendChild(optionSharp);
                        const optionFlat = document.createElement('option');
                        optionFlat.value = `${info.id}_flat`;
                        optionFlat.textContent = info.alt;
                        rootNoteSelect.appendChild(optionFlat);
                    }
                });
            }
            const filteredDefinitions = getFilteredDefinitions(currentMode);
            typeSelect.innerHTML = '';
            let firstKey = null;
            Object.keys(filteredDefinitions).forEach(key => {
                if (firstKey === null) firstKey = key;
                const option = document.createElement('option');
                option.textContent = filteredDefinitions[key].name;
                option.value = key;
                typeSelect.appendChild(option);
            });
            if (firstKey) {
                typeSelect.value = firstKey;
            }
            if (inversionSelect.options.length === 0) {
                INVERSIONS.forEach(inv => {
                    const option = document.createElement('option');
                    option.value = inv.value;
                    option.textContent = inv.name;
                    inversionSelect.appendChild(option);
                });
            }
        }
        function updateVisualization() {
            const rootValue = rootNoteSelect.value;
            const [rootIndexStr, rootPreference] = rootValue.split('_');
            const rootIndex = parseInt(rootIndexStr);
            const typeKey = typeSelect.value;
            let inversionIndex = parseInt(inversionSelect.value);
            const definition = DEFINITIONS[typeKey];
            if (!definition) {
                resultName.textContent = "Select a valid Type";
                drawKeyboard([], 'sharp');
                inversionSelect.disabled = true;
                return;
            }
            const isScale = definition.isScale;
            const isChord = !isScale;
            inversionSelect.disabled = !isChord;
            if (isChord) {
                const maxAllowedInversion = definition.min_notes - 1;
                Array.from(inversionSelect.options).forEach(option => {
                    const invValue = parseInt(option.value);
                    option.disabled = invValue > maxAllowedInversion;
                });
                if (inversionIndex > maxAllowedInversion) {
                     inversionIndex = 0;
                     inversionSelect.value = 0;
                }
            } else {
                inversionIndex = 0;
                inversionSelect.value = 0;
            }
            const rootInfo = { rootIndex, rootPreference };
            const result = calculateNotes(rootInfo, typeKey, inversionIndex);
            const KEYBOARD_WIDTH = KEYBOARD_CONFIG.KEYBOARD_WIDTH;
            const KEYBOARD_HEIGHT = KEYBOARD_CONFIG.KEYBOARD_HEIGHT;
            const VISIBLE_WIDTH = 950;
            const highlightedIndices = result.highlighted;
            let targetScrollX = 0;
            if (highlightedIndices.length > 0) {
                const firstHighlightedIndex = highlightedIndices[0];
                const minX = getKeyXPosition(firstHighlightedIndex);
                const lastHighlightedIndex = highlightedIndices[highlightedIndices.length - 1];
                const lastXStart = getKeyXPosition(lastHighlightedIndex);
                const noteMod12 = lastHighlightedIndex % 12;
                const isLastKeyWhite = [0, 2, 4, 5, 7, 9, 11].includes(noteMod12);
                const lastKeyWidth = isLastKeyWhite ? KEYBOARD_CONFIG.WHITE_KEY_WIDTH : KEYBOARD_CONFIG.BLACK_KEY_WIDTH;
                const maxX = lastXStart + lastKeyWidth;
                const spanCenter = (minX + maxX) / 2;
                targetScrollX = spanCenter - (VISIBLE_WIDTH / 2);
                targetScrollX = Math.max(0, targetScrollX);
                targetScrollX = Math.min(KEYBOARD_WIDTH - VISIBLE_WIDTH, targetScrollX);
            }
            if (KEYBOARD_WIDTH <= VISIBLE_WIDTH) {
                targetScrollX = 0;
            }
            if (isChord) {
                svg.setAttribute('width', `100%`);
                keyboardContainer.classList.remove('overflow-x-scroll');
                keyboardContainer.classList.add('overflow-x-hidden');
                svg.setAttribute('viewBox', `${targetScrollX} 0 ${VISIBLE_WIDTH} ${KEYBOARD_HEIGHT}`);
            } else {
                svg.setAttribute('width', `${KEYBOARD_WIDTH}px`);
                keyboardContainer.classList.add('overflow-x-scroll');
                keyboardContainer.classList.remove('overflow-x-hidden');
                svg.setAttribute('viewBox', `0 0 ${KEYBOARD_WIDTH} ${KEYBOARD_HEIGHT}`);
                requestAnimationFrame(() => {
                    const currentDefinition = DEFINITIONS[typeSelect.value];
                    if (currentDefinition && currentDefinition.isScale) {
                        keyboardContainer.scrollLeft = targetScrollX;
                    }
                });
            }
            drawKeyboard(result.highlighted, result.rootPreference);
            resultName.textContent = result.name;
        }
        rootNoteSelect.addEventListener('change', updateVisualization);
        typeSelect.addEventListener('change', updateVisualization);
        inversionSelect.addEventListener('change', updateVisualization);
        window.onload = () => {
            document.getElementById('chordModeBtn').addEventListener('click', () => handleModeChange('chord'));
            document.getElementById('scaleModeBtn').addEventListener('click', () => handleModeChange('scale'));
            updateModeButtons();
            populateSelectors();
            updateVisualization();
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('./service-worker.js')
                .then(reg => console.log('Service Worker registered successfully', reg))
                .catch(err => console.log('Service Worker registration failed:', err));
            }
        };
        window.addEventListener('resize', updateVisualization);
    </script>
</body>
</html>
