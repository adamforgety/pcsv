
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- CRITICAL for iPad/Tablet Compatibility -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Piano Visualizer App</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the visualizer */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        .key-shadow {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen flex items-center justify-center">

    <div class="w-full max-w-4xl bg-white rounded-xl shadow-2xl p-6 md:p-10">
        <header class="mb-8">
            <h1 class="text-3xl md:text-4xl font-extrabold text-gray-900 mb-2 rotate-1 text-center">
                Piano Chord & Scale Visualizer
            </h1>
            <p class="text-center text-gray-600 text-sm md:text-base">
                Visualize harmony on your phone or tablet.
            </p>
        </header>

        <!-- Selection Controls: Uses sm:grid-cols-3 for tablet layout -->
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-8">

            <!-- Root Note Selector -->
            <div class="space-y-1">
                <label for="rootNote" class="block text-sm font-medium text-gray-700">Root Note</label>
                <select id="rootNote" class="block w-full pl-3 pr-10 py-3 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-lg rounded-lg border key-shadow bg-gray-50">
                    <!-- Options populated by JS -->
                </select>
            </div>

            <!-- Type Selector (Chords/Scales) -->
            <div class="space-y-1">
                <label for="type" class="block text-sm font-medium text-gray-700">Chord / Scale Type</label>
                <select id="type" class="block w-full pl-3 pr-10 py-3 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-lg rounded-lg border key-shadow bg-gray-50">
                    <!-- Options populated by JS -->
                </select>
            </div>

            <!-- Inversion Selector -->
            <div class="space-y-1">
                <label for="inversion" class="block text-sm font-medium text-gray-700">Inversion (Chords Only)</label>
                <select id="inversion" class="block w-full pl-3 pr-10 py-3 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-lg rounded-lg border key-shadow bg-gray-50" disabled>
                    <!-- Options populated by JS -->
                </select>
            </div>
        </div>

        <!-- Visualization Area -->
        <div class="flex flex-col items-center">
            <h2 id="resultName" class="text-xl font-semibold text-gray-800 mb-3 text-center h-6"></h2>
            
            <!-- Small Screen Tip (Only visible on mobile/portrait) -->
            <div class="md:hidden w-full text-center text-sm p-2 bg-yellow-100 text-yellow-800 rounded-lg mb-4 key-shadow">
                ðŸ’¡ Rotate your device to landscape for the best keyboard view!
            </div>
            
            <!-- Keyboard Container -->
            <div id="keyboardContainer" class="relative w-full overflow-x-hidden p-4 bg-gray-100 rounded-lg key-shadow touch-pan-x">
                <svg id="pianoSvg" width="100%" height="220" viewBox="0 0 1900 220" preserveAspectRatio="xMidYMid slice"></svg>
            </div>
            
            <div id="noteDisplay" class="mt-4 text-lg font-mono text-gray-700 h-6 select-all"></div>
        </div>
    </div>

    <script>
        // --- Core Configuration Data ---
        const NOTE_INFO = [
            { id: 0, name: "C", alt: "C" },
            { id: 1, name: "C#", alt: "Db" },
            { id: 2, name: "D", alt: "D" },
            { id: 3, name: "D#", alt: "Eb" },
            { id: 4, name: "E", alt: "E" },
            { id: 5, name: "F", alt: "F" },
            { id: 6, name: "F#", alt: "Gb" },
            { id: 7, name: "G", alt: "G" },
            { id: 8, name: "G#", alt: "Ab" },
            { id: 9, name: "A", alt: "A" },
            { id: 10, name: "A#", alt: "Bb" },
            { id: 11, name: "B", alt: "B" }
        ];

        const DEFINITIONS = {
            'major': { intervals: [0, 4, 7], name: 'Major Chord', min_notes: 3, isScale: false },
            'minor': { intervals: [0, 3, 7], name: 'Minor Chord', min_notes: 3, isScale: false },
            'dom7': { intervals: [0, 4, 7, 10], name: 'Dominant 7th', min_notes: 4, isScale: false },
            'min7': { intervals: [0, 3, 7, 10], name: 'Minor 7th', min_notes: 4, isScale: false },
            
            'major_scale': { intervals: [0, 2, 4, 5, 7, 9, 11], name: 'Major Scale', min_notes: 7, isScale: true },
            'minor_scale': { intervals: [0, 2, 3, 5, 7, 8, 10], name: 'Natural Minor Scale', min_notes: 7, isScale: true },
            'pentatonic_major': { intervals: [0, 2, 4, 7, 9], name: 'Pentatonic Major Scale', min_notes: 5, isScale: true },
            'pentatonic_minor': { intervals: [0, 3, 5, 7, 10], name: 'Pentatonic Minor Scale', min_notes: 5, isScale: true },
        };

        const INVERSIONS = [
            { value: 0, name: "Root Position" },
            { value: 1, name: "1st Inversion" },
            { value: 2, name: "2nd Inversion" },
            { value: 3, name: "3rd Inversion" } 
        ];

        // --- Keyboard Drawing Configuration ---
        const KEYBOARD_CONFIG = {
            TOTAL_KEYS: 49, // C3 (0) to C7 (48)
            WHITE_KEYS_COUNT: 29, 
            KEYBOARD_WIDTH: 1900, // Total SVG width
            KEYBOARD_HEIGHT: 220, // Total SVG height for clipping prevention
            KEY_Y_START: 10,       // Vertical offset for padding
            WHITE_KEY_HEIGHT: 200, 
            WHITE_KEY_WIDTH: 1900 / 29, 
            BLACK_KEY_WIDTH: (1900 / 29) * 0.6,
            BLACK_KEY_HEIGHT: 120,
        };

        /**
         * Returns the full note name (e.g., "C4", "Db4") with octave, respecting the root's spelling preference.
         */
        function getNoteFullName(globalIndex, spellingPreference) {
            const octave = 3 + Math.floor(globalIndex / 12);
            const semitoneIndex = globalIndex % 12;
            const info = NOTE_INFO[semitoneIndex];

            let baseName;
            if (info.name === info.alt) {
                baseName = info.name;
            } else if (spellingPreference === 'flat') {
                baseName = info.alt; 
            } else {
                baseName = info.name; 
            }

            return baseName + octave;
        }

        /**
         * Helper to find the starting X position (in SVG units) of a key given its absolute index (0-48).
         */
        function getKeyXPosition(absoluteIndex) {
            if (absoluteIndex < 0 || absoluteIndex >= KEYBOARD_CONFIG.TOTAL_KEYS) {
                return -999; 
            }

            const noteMod12 = absoluteIndex % 12; 
            const isWhiteKey = [0, 2, 4, 5, 7, 9, 11].includes(noteMod12);
            
            const WKW = KEYBOARD_CONFIG.WHITE_KEY_WIDTH;
            const BKW = KEYBOARD_CONFIG.BLACK_KEY_WIDTH;

            let whiteKeyCount = 0;
            for (let i = 0; i < absoluteIndex; i++) {
                if ([0, 2, 4, 5, 7, 9, 11].includes(i % 12)) {
                    whiteKeyCount++;
                }
            }
            
            if (isWhiteKey) {
                return whiteKeyCount * WKW; 
            } else {
                const x = (whiteKeyCount * WKW) - (BKW / 2);
                return x;
            }
        }
        
        /**
         * Calculates the note indices, name, and octave offset for the selected chord/scale.
         */
        function calculateNotes(rootInfo, typeKey, inversionIndex) {
            const { rootIndex, rootPreference } = rootInfo;
            const definition = DEFINITIONS[typeKey];
            if (!definition) return { highlighted: [], name: "Invalid Type", notesText: "", rootPreference: rootPreference };

            const highlightedNotes = [];
            let intervals = [...definition.intervals];
            
            let rootNameDisplay = NOTE_INFO[rootIndex].name;
            if (rootPreference === 'flat' && NOTE_INFO[rootIndex].alt !== NOTE_INFO[rootIndex].name) {
                rootNameDisplay = NOTE_INFO[rootIndex].alt;
            }
            let name = rootNameDisplay + " " + definition.name;

            const isChord = !definition.isScale;
            const maxInversion = definition.min_notes - 1; 

            if (!isChord && intervals.length === 7) { 
                intervals.push(12); // Full R-to-R scale
            }
            
            if (isChord && inversionIndex > 0 && inversionIndex <= maxInversion) {
                for (let i = 0; i < inversionIndex; i++) {
                    intervals.push(intervals.shift() + 12);
                }
                name += ` (${INVERSIONS[inversionIndex].name})`;
            }

            let octaveOffset = 0; 
            const highestInterval = intervals[intervals.length - 1] || 0; 
            const highestNeededSemitone = rootIndex + highestInterval; 
            const maxKeyIndex = KEYBOARD_CONFIG.TOTAL_KEYS - 1;

            if (isChord) {
                // Try to fit the chord in the 4th octave (C4-B4) if possible
                if (highestNeededSemitone + 12 <= maxKeyIndex) {
                    octaveOffset = 12; 
                } 
                else if (highestNeededSemitone + 0 <= maxKeyIndex) {
                    octaveOffset = 0; 
                }
                else if (rootIndex + octaveOffset >= 0) {
                    octaveOffset = -12; 
                }
            } else {
                // Scales usually start lower for better visualization
                const idealOffset = 12; // Start C3
                const candidateHighestSemitone = rootIndex + highestInterval + idealOffset;

                if (candidateHighestSemitone <= maxKeyIndex) {
                    octaveOffset = idealOffset; 
                } 
                else {
                    octaveOffset = 0; 
                }
            }

            intervals.forEach(interval => {
                let finalIndex = rootIndex + interval + octaveOffset;
                
                if (finalIndex >= 0 && finalIndex <= maxKeyIndex) {
                    highlightedNotes.push(finalIndex);
                }
            });

            const uniqueNotes = Array.from(new Set(highlightedNotes)).sort((a, b) => a - b);
            const noteNamesArray = uniqueNotes.map(index => getNoteFullName(index, rootPreference)); 
            
            return { 
                highlighted: uniqueNotes, 
                name: name, 
                notesText: noteNamesArray.join(', '), 
                isScale: definition.isScale || false,
                rootPreference: rootPreference 
            };
        }

        /**
         * Draws the piano keyboard SVG, highlighting the calculated notes.
         */
        function drawKeyboard(highlightedIndices = [], viewBoxX = 0, rootPreference = 'sharp') {
            const svg = document.getElementById('pianoSvg');
            svg.innerHTML = '';
            
            const keyboardViewHeight = KEYBOARD_CONFIG.KEYBOARD_HEIGHT;
            const VISIBLE_WIDTH = 950;
            
            svg.setAttribute('viewBox', `${viewBoxX} 0 ${VISIBLE_WIDTH} ${keyboardViewHeight}`);
            
            const WKW = KEYBOARD_CONFIG.WHITE_KEY_WIDTH;
            const BKW = KEYBOARD_CONFIG.BLACK_KEY_WIDTH;
            const WKH = KEYBOARD_CONFIG.WHITE_KEY_HEIGHT;
            const Y_START = KEYBOARD_CONFIG.KEY_Y_START;

            let whiteKeyIndex = 0;
            
            const WHITE_KEY_COLOR = '#ffffff';
            const BLACK_KEY_COLOR = '#1f2937'; 
            const HIGHLIGHT_WHITE_COLOR = '#3b82f6'; 
            const HIGHLIGHT_BLACK_COLOR = '#1d4ed8'; 
            
            // 1. Draw White Keys (Background)
            for (let i = 0; i < KEYBOARD_CONFIG.TOTAL_KEYS; i++) {
                const semitoneIndex = i % 12;
                const noteName = NOTE_INFO[semitoneIndex].name + (3 + Math.floor(i / 12)); 

                if ([0, 2, 4, 5, 7, 9, 11].includes(semitoneIndex)) {
                    const isHighlighted = highlightedIndices.includes(i);
                    const x = whiteKeyIndex * WKW;
                    
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute('x', x);
                    rect.setAttribute('y', Y_START); 
                    rect.setAttribute('width', WKW);
                    rect.setAttribute('height', WKH); 
                    rect.setAttribute('rx', 4);
                    rect.setAttribute('ry', 4);
                    rect.setAttribute('stroke', '#a1a1aa'); 
                    rect.setAttribute('stroke-width', '1');
                    
                    rect.setAttribute('fill', isHighlighted ? HIGHLIGHT_WHITE_COLOR : WHITE_KEY_COLOR); 
                    rect.classList.add('white-key');
                    
                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute('x', x + WKW / 2);
                    text.setAttribute('y', Y_START + WKH - 10);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', '14');
                    text.setAttribute('fill', isHighlighted ? '#ffffff' : '#4b5563'); 
                    text.textContent = noteName;

                    svg.appendChild(rect);
                    svg.appendChild(text);

                    whiteKeyIndex++;
                }
            }
            
            // 2. Draw Black Keys (Foreground)
            for (let i = 0; i < KEYBOARD_CONFIG.TOTAL_KEYS; i++) {
                const semitoneIndex = i % 12;
                if ([1, 3, 6, 8, 10].includes(semitoneIndex)) {
                    const isHighlighted = highlightedIndices.includes(i);
                    
                    let whiteKeyToTheLeftIndex = 0;
                    for (let j = 0; j < i; j++) {
                        if ([0, 2, 4, 5, 7, 9, 11].includes(j % 12)) {
                            whiteKeyToTheLeftIndex++;
                        }
                    }

                    const x = (whiteKeyToTheLeftIndex * WKW) - (BKW / 2);
                        
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute('x', x);
                    rect.setAttribute('y', Y_START); 
                    rect.setAttribute('width', BKW);
                    rect.setAttribute('height', KEYBOARD_CONFIG.BLACK_KEY_HEIGHT);
                    rect.setAttribute('rx', 3);
                    rect.setAttribute('ry', 3);
                    rect.setAttribute('stroke', '#000000');
                    rect.setAttribute('stroke-width', '1');
                    
                    rect.setAttribute('fill', isHighlighted ? HIGHLIGHT_BLACK_COLOR : BLACK_KEY_COLOR); 
                    rect.classList.add('black-key');
                    
                    svg.appendChild(rect);
                    
                    if (isHighlighted) {
                        const noteInfo = NOTE_INFO[semitoneIndex];
                        let noteBaseName;
                        if (rootPreference === 'flat' && noteInfo.alt !== noteInfo.name) {
                            noteBaseName = noteInfo.alt; 
                        } else {
                            noteBaseName = noteInfo.name; 
                        }

                        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        text.setAttribute('x', x + BKW / 2);
                        text.setAttribute('y', Y_START + KEYBOARD_CONFIG.BLACK_KEY_HEIGHT - 10);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('font-size', '14');
                        text.setAttribute('fill', '#ffffff');
                        text.textContent = noteBaseName; 

                        svg.appendChild(text);
                    }
                }
            }
        }


        // --- UI Initialization and Event Handling ---
        
        const rootNoteSelect = document.getElementById('rootNote');
        const typeSelect = document.getElementById('type');
        const inversionSelect = document.getElementById('inversion');
        const resultName = document.getElementById('resultName');
        const noteDisplay = document.getElementById('noteDisplay');

        function populateSelectors() {
            NOTE_INFO.forEach(info => {
                // If the note has no alternative spelling (C, D, E, F, G, A, B)
                if (info.name === info.alt) {
                    const option = document.createElement('option');
                    option.value = `${info.id}_sharp`; // Default to sharp spelling for natural notes
                    option.textContent = info.name;
                    // Set 'C' (id 0) as the default root note selection
                    if (info.id === 0) { 
                        option.selected = true; 
                    }
                    rootNoteSelect.appendChild(option);
                } else {
                    // Sharp spelling (C#, D#, F#, G#, A#, E#, B#)
                    const optionSharp = document.createElement('option');
                    optionSharp.value = `${info.id}_sharp`; 
                    optionSharp.textContent = info.name; 
                    rootNoteSelect.appendChild(optionSharp);

                    // Flat spelling (Db, Eb, Gb, Ab, Bb, Cb, Fb)
                    const optionFlat = document.createElement('option')
                    optionFlat.value = `${info.id}_flat`; 
                    optionFlat.textContent = info.alt; 
                    // Removed old Db default selection logic
                    rootNoteSelect.appendChild(optionFlat);
                }
            });
            
            Object.keys(DEFINITIONS).forEach(key => {
                const option = document.createElement('option');
                option.textContent = DEFINITIONS[key].name;
                option.value = key;
                // Changed default from 'major_scale' to 'major' (Major Chord)
                if(key === 'major') option.selected = true; 
                typeSelect.appendChild(option);
            });

            INVERSIONS.forEach(inv => {
                const option = document.createElement('option');
                option.value = inv.value;
                option.textContent = inv.name;
                inversionSelect.appendChild(option);
            });
        }
        
        // Main function to update the visualization
        function updateVisualization() {
            const rootValue = rootNoteSelect.value;
            const [rootIndexStr, rootPreference] = rootValue.split('_');
            const rootIndex = parseInt(rootIndexStr);

            const typeKey = typeSelect.value;
            let inversionIndex = parseInt(inversionSelect.value);

            const definition = DEFINITIONS[typeKey];

            const isChord = !definition.isScale;
            inversionSelect.disabled = !isChord;
            
            const maxAllowedInversion = definition.min_notes - 1;
            
            // Disable inversion options that don't apply to the selected chord
            Array.from(inversionSelect.options).forEach(option => {
                const invValue = parseInt(option.value);
                option.disabled = isChord && invValue > maxAllowedInversion;
            });
            
            // Reset inversion if the current selection is not valid for the new type
            if (!isChord || inversionIndex > maxAllowedInversion) {
                 inversionIndex = 0;
                 inversionSelect.value = 0;
            }

            const rootInfo = { rootIndex, rootPreference };
            const result = calculateNotes(rootInfo, typeKey, inversionIndex);
            
            // --- CENTERING LOGIC (Keyboard) ---
            const VISIBLE_WIDTH = 950;
            const KEYBOARD_WIDTH = KEYBOARD_CONFIG.KEYBOARD_WIDTH;
            const highlightedIndices = result.highlighted;
            let viewBoxX = 0;

            if (highlightedIndices.length > 0) {
                const firstHighlightedIndex = highlightedIndices[0];
                const minX = getKeyXPosition(firstHighlightedIndex);
                const lastHighlightedIndex = highlightedIndices[highlightedIndices.length - 1];
                const lastXStart = getKeyXPosition(lastHighlightedIndex);
                
                const noteMod12 = lastHighlightedIndex % 12;
                const isWhiteKey = [0, 2, 4, 5, 7, 9, 11].includes(noteMod12);
                const lastKeyWidth = isWhiteKey ? KEYBOARD_CONFIG.WHITE_KEY_WIDTH : KEYBOARD_CONFIG.BLACK_KEY_WIDTH;
                const maxX = lastXStart + lastKeyWidth;

                const spanCenter = (minX + maxX) / 2;
                viewBoxX = spanCenter - (VISIBLE_WIDTH / 2);

                // Clamp the viewBoxX to keep the view within the keyboard bounds
                viewBoxX = Math.max(0, viewBoxX);
                viewBoxX = Math.min(KEYBOARD_WIDTH - VISIBLE_WIDTH, viewBoxX);
            }

            if (KEYBOARD_WIDTH <= VISIBLE_WIDTH) {
                viewBoxX = 0;
            }

            drawKeyboard(result.highlighted, viewBoxX, result.rootPreference);
            
            resultName.textContent = result.name;
            noteDisplay.textContent = result.notesText;
        }
        
        // Add event listeners for interactivity (handles touch on iPad/mobile)
        rootNoteSelect.addEventListener('change', updateVisualization);
        typeSelect.addEventListener('change', updateVisualization);
        inversionSelect.addEventListener('change', updateVisualization);

        // Initial setup on load
        window.onload = () => {
            populateSelectors();
            updateVisualization();
        };

        // Handle window resize to ensure responsiveness
        window.addEventListener('resize', updateVisualization);

    </script>
</body>
</html>
